---
layout: post
title:  "Turbo Prolog basics"
date:   2017-11-11 01:18:48 +0300
categories: turbo prolog
---
# Turbo Prolog. Основы

Пролог-программы состоят из *термов*. Терм - это либо *константа*, либо *переменная*, либо *структура*. Терм записывается как последовательность *литер*.

Константами являются поименованные *конкретные объекты* или *конкретные отношения*. Существует два вида констант - *атомы* и *целые числа*. Есть два вида атомов -
составленные из букв и цифр и составленные из спецзнаков. Имена констант и переменных образованы цепочками литер.

Переменная является термом, который начинается с заглавной буквы или знака нижнего подчёркивания. Переменные бывают именованные и анонимные. Анонимная пееменная состоит из одиночного знака подчёркивания.

*Структура* - это единый объект, состоящий из совокупности других объектов, называемых компонентами. Компоненты группируются в структуру для удобства их использования. Структура записывается на Прологе с помошью указания её *функтора* и *компонент*. Компоненты заключаются в круглые скобки и разделяются запятыми. Функтор записывается перед открывающей круглой скобкой. Предикат (используемый в фактах и правилах) является на самом деле функтором некоторой структуры. Аргументы факта и правила - это компоненты структуры.

 
В Турбо Прологе факты и правила называются утверждениями.
Утверждения записываются в разделе clauses.

Каждое утверждение заканчивается точкой.

Каждая программа на прологе имеет цель.
Цель по своей структуре является фактом и\или правилом. 
Цель бывает внутренней и внешней. Внешние цели заставляют пролог находить все решения, удовлетворяющие цели. Внутрение цели заставляют пролог остановиться после первого успешного сопоставления цели.

Унификация - процесс сопоставления правил и фактов. Сначала сопоставляются предикаты, потом сопоставляются объекты.

В случае переменной, неозначенная переменная при сопоставлении с константой получает значение этой константы. Подпрограммы унификации присваивают переменной конкретное значение только во время сопоставления. Переменная вновь становится свободной, когда сопоставление оказывается неуспешным или цель оказывается успешно вычисленной.

В Турбо Прологе присваивание может быть осуществлено в обоих направлениях. Зависит от того, с какой стороны стоит несвязанная переменная. Что произойдёт, если мы попытаемся приравнять две неконкретизированные переменные? Цель будет согласована и две переменные станут *сцепленными*. Если две переменные сцеплены, то при конкретизации одной из них второй переменной будет автоматически присвоено то же самое конкретное значение, что и первой.

Если имя объекта начинается со строчной буквы, то этот объект имеет известное значение.
Если имя объекта начинается с заглавной буквы, то объект является переменной.

Откат (Бектрекинг?) - это механизм, который Пролог использует для нахождения дополнительных фактов и правил, необходимых при вычислении цели, если текущая попытка вычислить цель оказалась неудачной.

### Вычисление арифметических выражений

В прологе от Клоксина и Меллиша для вычисления арифметических операций используется предикат is. В Турбо-Прологе этого можно не делать, а просто использовать арифметические операции как предикаты.

### Разделы в программе на Турбо Прологе

- раздел domains содержит определения доменов, которые описывают различные классы объектов, используемых в программе.

- раздел database содержит утверждения базы данных, которые являются предикатами динамической базы данных. Если программа такой базы данных не требует, то этот раздел может быть опущен.

- раздел predicates служит для описания используемых программой предикатов.

- в разделе goal формулируется назначение создаваемой программы. Это раздел описания цели. Составными частями при этом могут являться некие подцели, из которых формируется единая цель программы.

- в раздел clauses заносятся факты и правила, известные априорно (утверждения). Это данные, необходимых для работы программы. 

Комментарии обозначаются символами /* */.

Турбо Пролог требует указание типов объектов для каждого предиката программы.
Пример:
```
domains
 person, thing = symbol
predicates
 likes(person, thing)
```
 
### Описание встроенных типов доменов Турбо-Пролога.

|Тип данных | Ключевое слово|Диапазон значений|
|-----------|---------------|----------------|
|Символ|char|Все символы|
|Целое число|integer|-32768..+32767|
|Действительное число|real|1E-307..1E308|
|Строка|string|Последовательность символов (не более 250 символов)|
|Символьное имя|symbol|строка, начинающаяся со строчной буквы либо строка, заключённая в кавычки|
|Файл|file|Допустимое имя ДОС файла|

### Описание предикатов

Предикаты используются для представления как данных, так и правил для оперирования данными. Терм предиката представляет собой строку символов, первым из которых является строчная буква. Предикаты описываются в разделе predicates.

Перечень объектов предиката заключается в круглые скобки, а в качестве разделителя используется запятая.
Пример:
``` 
predicates
	likes(symbol,symbol)
```

Следующие описания предикатов эквивалентны:
```
book(symbol,symbol,integer)

domains
	title,author = symbol
	year = integer
predicates
	book(title,author,year)
```

Функтор - структура, представляющая собой объект. Функтор определяется в разделе доменов.

Пример:
```
 personal_library = book(title)
 title = symbol
```

, где book - это функтор.
Предикат, использующий эту структуру, определяется так:
`collection(collector,personal_library).`

Чем больше функторов, тем более определённые запросы можно задавать базе данных.

Турбо-Пролог поддерживает определение множественного описания доменов. Например:

```
domains
	thing = misc_thing(whatever) ;
		book(author,title) ;
		record(artist,album,type)
		
	whatever,person,author,title,artist,album,type = symbol

predicates
	owns(person, thing)

clauses
	owns("Bill",misc_thing("sail boat")).
	owns("Bill",book("Tolkien","Return of the king")).
	owns("Joe",record("Elton John","Ice Fair",popular)).
```

Как видно, определение альтернативных доменов разделяется с помощью точки с запятой.

При этом можно составить следующие цели:
```
owns(P,misc_thing(T)).
owns(_,book(A,T)).
owns(P,record(_,A_)).
```

### Повтор и рекурсия

Методы:
- метод отката после неудачи
- метод отсечения и отката
- правило повтора, определённое пользователем
- обобщённое рекурсивное правило.


Вид правила, выполняющего повторение, следующий:
```
rep_rule:-
	<predicates and rules>,
	fail.
```

Встроенный предикат fail вызывает откат, так что предикаты и правила выполняются ещё раз. Правило повтора, использующее откат, не увеличивает занятую часть стека.

Рекурсивное правило имеет следующий вид:
```
rec_rule:-
	<predicates and rules>,
	rec_rule.
```

Предикат fail вызывает откат к следующему утверждении, которое может обеспечить вычисление цели. 	

### Метод отсечения и отката

Метод отсечения и отката может быть использован для фильтрации данных, выбираемых из утверждений базы данных. Предикат cut обозначается знаком !. Этот предикат, вычисление котрого всегда завершается успешно, заставляет механизмы унификации забыть все указатели отката, установленные во время попыток вычислить текущую подцель. 

### Метод повтора, определяемый пользователем

Вид правила повтора, определяемого пользователем, имеет следующий вид:

```
repeat.
repeat:-repeat.
```

Первый предикат repeat является утверждением, объявляющим предикат repeat истинным. Однако, поскольку имеется ещё один вариант для этого правила, то указатель отката устанавливается на первый repeat. Второй repeat - это правило, которое использует само себя как компоненту. Второй repeat вызывает третий repeat, и этот вызов вычисляется успешно, так как первый repeat удовлетворяет подцели repeat. Следовательно, правило repeat так же всегда успешно. Предикат repeat будет вычисляться успешно при каждой новой попытке его вызвать после отката. 

Пример, программы, в котором используется повтор, приведён далее. Программа выводит на экран то, что пользователь ввёл с клавиатуры. Программа заканчивает работу, когда пользователь вводит слово stop.

```
/*
Program demonstrates how to use iterations.
*/
predicates
	do_echo
	check(symbol)
	repeat
clauses
	repeat.
	repeat:-repeat.
	
	do_echo:-
		repeat,
		readln(Name),
		write(Name),nl,
		check(Name),!.
	check(stop):-
		nl,write(" - OK, bye!").
	check(Name):-fail.
```
	
### Метод обобщенного правила рекурсии

В общем виде оно выглядит так:

```
<имя правила рекурсии> :-
		<список предикатов>,
		<предикат условия выхода>,
		<список предикатов>,
		<имя правила рекурсии>,
		<список предикатов>.
```
	
### Отладка программы в Турбо-Прологе

Чтобы запустить программу в режиме отладки, необходимо в начале программы прописать директиву shortrace.

После этого можно запустить программу. Для перехода к следующему шагу программы необходимо нажимать комбинацию F10.  При этом в окне Trace будут отображаться результаты трассировки.

|Значение|Расшифровка|
|--------|-----------|
|call|Каждый раз при вызове предиката в окне трассировки будет отображаться имя вызываемого предиката, а также значения передаваемых параметров.|
|return|RETURN отображается в окне трассировки, когда утверждение истино и предикат совершил возврат. Если существуют другие утверждения, которые удовлетворяют входным параметрам, то будет отображаться звёздочка, как индикатор того, что утверждение находится в точке возврата.|
|fail|При невозможности доказательства предиката отображается слово FAIL, за которым следует имя этого предиката и его аргументы.|
|redo|REDO указывает на то, что произошёл возврат с откатом. В окне трассировки отображаются имя предиката, на котором произошёл откат, а также значения его параметров.|


### Список

Список - это упорядоченная последовательность элементов, которая может иметь произвольную длину. 

Элементами списка могут быть любыте термы - константы, переменые, структуры.

Работа со списками основана на расщеплении их на *голову* и *хвост* списка.
Заметим, что пустой список ([]) не имеет ни головы ни хвоста.

Турбо-Пролог позволяет выполять со списком целый ряд операций. Их перечень включает:

- доступ к спискам объекта
- проверка на принадлежность к списку
- разделение списка на два
- слияние двух списков
- сортировка элементов списка в порядке возастания или убывания

Краткое введение закончено. Далее можно почитать Клоксина и Меллиша.